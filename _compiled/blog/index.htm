<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="author" content="">
<meta name="keywords" content="">
<title> snyh blog </title>
<link rel="stylesheet" href="/assets/css/bootstrap.min.css">
<link rel="stylesheet" href="/assets/css/page.css">


<style>
body {
	padding-top: 60px;
}
</style>
<link href="/assets/css/bootstrap-responsive.min.css" rel="stylesheet">
<!--[if lt IE9]>
<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="shortcut icon" href="/assets/img/favicon.png">
</head>
<body>

<div class="navbar navbar-fixed-top">
<div class="navbar-inner">

<div class="container">

<a class="brand" href=""> snyh.org </a>

<ul class="nav">

<li><a href=/>主页</a></li>

<li><a href=/blog/>随笔</a></li>

<li><a href=/album/>往夕</a></li>

<li><a href=/project/>实验田</a></li>

<li><a href=/about.html>关于</a></li>

</ul>

<div class="pull-right">

<!-- JiaThis Button BEGIN -->
<span id="jiathis_style_32x32">
	<a class="jiathis_button_tsina"></a>
	<a class="jiathis_button_tqq"></a>
	<a class="jiathis_button_renren"></a>
	<a class="jiathis_button_kaixin001"></a>
	<a class="jiathis_button_douban"></a>
	<a class="jiathis_button_qzone"></a>
	<a class="jiathis_button_pdfonline"></a>
	<a href="http://www.jiathis.com/share?uid=1584728" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	<a class="jiathis_counter_style"></a>
</span>
<!-- JiaThis Button END -->

<input type="text" class="search-query" placeholder="Search">
</div>

</div>

</div>
</div>




<div class="container">
<div class="row">
	<div class="span9">
		
		
<h2>
<a href=/blog/2012/03/07/drawwords.html>字模生俱生成.</a>
<a href="/blog/category/blogtest"><span class="label label-info">blogtest</span></a>

</h2> 
<small>时间:2012-03-07 00:00:00 +0800 </small>


<span>
	
</span>


<hr>


<p> 字模数据生成. 较早写的一个小程序, 主要是给另外一个程序做数据生成用的. 使用freetype2读取数据 支持任何大部分字体, 默认直接打印出字体的图样到console, 如果指定输出文件则输出字模数据到指定文件. 需要指定字体文件默认使用./font/wqy.tty 由于字体文件较大所以没有上传上来. 默认帮助信息 This program convert letter to matrix data Usage: gend [OPTION]... [STRING]... -i, --input-file &lt;arg&gt; file will used convert default used the STRING -o, --output-file &lt;arg&gt; file will be write the matrix data default file is 'output' -f, --font &lt;path&gt; use... </p>


<a href="/blog/2012/03/07/drawwords.html">Read more...</a>

<br/>

<h2>
<a href=/blog/2012/03/07/LFshare.html>项目页测试</a>
<a href="/blog/category/test"><span class="label label-info">test</span></a>

</h2> 
<small>时间:2012-03-07 00:00:00 +0800 </small>


<span>
	
	<a href="/blog/tags/test"><span class="label label-info">test</span></a>
	
	<a href="/blog/tags/snyh"><span class="label label-info">snyh</span></a>
	
	<a href="/blog/tags/project"><span class="label label-info">project</span></a>
	
</span>


<hr>


<p> 项目LFShare


  1
  2
  3


hello world
 </p>


<a href="/blog/2012/03/07/LFshare.html">Read more...</a>

<br/>

<h2>
<a href=/blog/2012/03/06/blogtest2.html>文章2测试</a>
<a href="/blog/category/blogtest2"><span class="label label-info">blogtest2</span></a>

</h2> 
<small>时间:2012-03-06 00:00:00 +0800 </small>


<span>
	
</span>


<hr>


<p> 
  list item 1
  list item 2
  list item 3

 </p>


<a href="/blog/2012/03/06/blogtest2.html">Read more...</a>

<br/>

<h2>
<a href=/blog/2012/02/12/0.3.3-release-note.html>elf+js[0.3.3]发布</a>
<a href="/blog/category/release"><span class="label label-info">release</span></a>

</h2> 
<small>时间:2012-02-12 00:00:00 +0800 </small>


<span>
	
	<a href="/blog/tags/0.3.3"><span class="label label-info">0.3.3</span></a>
	
	<a href="/blog/tags/elf+js"><span class="label label-info">elf+js</span></a>
	
	<a href="/blog/tags/release"><span class="label label-info">release</span></a>
	
	<a href="/blog/tags/bugfix"><span class="label label-info">bugfix</span></a>
	
	<a href="/blog/tags/发布"><span class="label label-info">发布</span></a>
	
	<a href="/blog/tags/版本"><span class="label label-info">版本</span></a>
	
</span>


<hr>


<p> 此版本对动画和拖动事件函数接口进行了统一化的调整，并修复节点集合集成动画调用一些问题，详见下方的变更记录。

你可以到项目的下载页面获取相关的发布代码，或者直接通过下面的链接来下载：

Included file ‘downloads/links.md’ not found in _includes directory

0.3.3版本变更记录：

Included file ‘version/0.3.3.md’ not found in _includes directory

不做单测很容易出现问题，有时候就用没时间的借口代替偷懒了。
 </p>


<a href="/blog/2012/02/12/0.3.3-release-note.html">Read more...</a>

<br/>

<h2>
<a href=/blog/2012/02/12/0.3.2-release-note.html>elf+js[0.3.2]发布</a>
<a href="/blog/category/release"><span class="label label-info">release</span></a>

</h2> 
<small>时间:2012-02-12 00:00:00 +0800 </small>


<span>
	
	<a href="/blog/tags/0.3.2"><span class="label label-info">0.3.2</span></a>
	
	<a href="/blog/tags/elf+js"><span class="label label-info">elf+js</span></a>
	
	<a href="/blog/tags/release"><span class="label label-info">release</span></a>
	
	<a href="/blog/tags/bugfix"><span class="label label-info">bugfix</span></a>
	
	<a href="/blog/tags/发布"><span class="label label-info">发布</span></a>
	
	<a href="/blog/tags/版本"><span class="label label-info">版本</span></a>
	
</span>


<hr>


<p> 此版本修复了在最近一段时间的使用中发现一些Bug，详见下方的变更记录。

另外，正如你现在看到的，除了在线打包工具和[]()以外，我们的站点已经迁移到github上托管了，项目地址是：https://github.com/elfjs/elfjs.github.com

如果有网站相关的问题，如错别字或者空链接等，欢迎到这里提交，或者在github上fork一份帮助我们改进。

你可以到项目的下载页面获取相关的发布代码，或者直接通过下面的链接来下载：


  0.3.2（）
  0.3.2（）


0.3.2版本变更记录：

Included file ‘version/0.3.2.md’ not found in _includes directory

虽然现在做的还不算好，但我们会默默的保持小步前进。
 </p>


<a href="/blog/2012/02/12/0.3.2-release-note.html">Read more...</a>

<br/>

<h2>
<a href=/blog/2011/12/28/how-to-participate-in-elfjs-via-franky.html>如何参与到elf+js项目中(via Franky Yang)</a>
<a href="/blog/category/communication"><span class="label label-info">communication</span></a>

</h2> 
<small>时间:2011-12-28 00:00:00 +0800 </small>


<span>
	
	<a href="/blog/tags/来信"><span class="label label-info">来信</span></a>
	
	<a href="/blog/tags/参与"><span class="label label-info">参与</span></a>
	
	<a href="/blog/tags/交流"><span class="label label-info">交流</span></a>
	
	<a href="/blog/tags/想法"><span class="label label-info">想法</span></a>
	
</span>


<hr>


<p> 在获得Franky的允许后，我决定把他的来信和我的回复发在这里，也希望有更多开发者朋友能和我们一起交流，谢谢Franky！

Franky Yang

2011年12月27日 11:28 发送至 我, elfjslib


  你好！

  我是在新浪微博上看到有人推荐你的项目，刚才花了一个小时浏览了博客、文档、从git上clone了代码并且浏览了目录，感觉很兴奋，我相信这是一个伟大的开始，我希望能够加入其中。

  我现在在……（此处省略Franky的自我介绍），看到jQuery版本号不断增加，体积不断增大时，也有这种想法。所以你的工程让我眼前一亮。还有全中文的博客以及文档，更是感觉很舒适。这样的一个JS库，对国人来说是很大的便利，从某种精神意义上讲，我也非常想把这件事能不断的被推动、深化下去，希望我自己能在这个过程中尽一份力。

  做为一个JS新手，我也希望在前期能够更多的得到你的指导，也许我还无法独立完成大型模块的开发，但是去完成一些定义明确的小模块还是没有问题的。希望能够由易到难，在你的指导下能得到更大的进步。

  对elf+js项目，我还不大清楚它的插件机制是怎样的，对于那句“如果把elf看做是使用方便瑞士军刀的话，那么jslib就是核心工具包中真正的一刀一斧”我还不是很清楚具体的含义，而且文档中也只有对API的介绍，未涉及扩展机制相关的内容，所以我猜这部分功能是否还不具备？我觉得对于现代的JS框架来说，一个扩展机制是很重要的，也是更多人参与的一个切入点。

  如果扩展出插件机制，我觉得同时支持jQuery和jQuery UI的插件应该不难吧，这有利于市场表现。

  此外，我想可以重点考虑对移动设备的支持，独立出一个对应的版本，库文件十来K大小，各方面都有一定优化。

  require库可以做到按需加载，如果方便引入，应该能够进一步提升加载页面速度。


mytharcher的回复：

Hi，Franky

非常感谢你的来信！很惊讶发布后这么快就能有人主动关注。

作为一个平常只是敝帚自珍的coder来说，听到有人愿意加入一起努力也感到异常的兴奋，甚至我自己都还没准备好如何让大家来一起参与，而既然放在来了github，我觉得fork一下应该是目前我想到最好的合作方式。或者我们可以就JS library的理解先进行一些沟通，看看我们各自对这个产品的期待是什么样的。

作为elf+js的作者，可以先分享一下我的想法和初衷。我认为elf+js目前是且仅是一个JavaScript Library，正如C/Java的工具库一样，提供的是很多通用的功能。所以我将jslib比喻为一个工具箱，里面每一把工具（类或函数）都可以解决一个普遍性的问题，例如js.dom.ClassName类专门处理DOM元素的classname增删改，js.net.Ajax专门处理异步请求等。这其实和dojo/yui等框架的部分思路是很相似的，不知道你是否了解过百度的Tangram项目，jslib的作用和目的与之更接近。而你应该可以从我对这些工具类的命名上可以看出，我更希望这些工具的代码组织方式是类似Java类库的一种严谨结构，而这样的结构本身就是一个天然插件池，增加一个类就像你可以随时买一把新的工具回来放在工具箱里，而不影响其他任何地方，只要这个工具真的有用而且好用。所以对于jslib来说不需要提及插件这个概念，如果一定需要，应该也是对jQuery使用的一种基于DOM封装的习惯性理解，这个部分可以详细看看目前js.dom.*包下很多以INode*开头接口实体的处理方式，基本和jQuery的思想一样，是在对Node集合类的prototype上增加处理方法。如果只是需要对DOM进行类似jQuery书写风格的插件设计，那么照这个方式进行扩展就可以了。

从上面这些点来看，jslib是一个比jQuery概念大一些的东西，也是我对他称之为“库”的一个理解。而大家其实在多数比较简单的网页应用中都喜欢挥舞着瑞士军刀一样的jQuery一路点下去$('xx').xxx().xxx()...的开发方式，的确这样的写法非常的amazing，让人容易上瘾，所以我根据开发者的这个喜好又设计了与tangram死板的函数库不同的elf。他对jslib中丰富的功能进行了易用性的封装，让你可以像写jQuery一样去开发。于是使用elf时你也可以写：elf('#test').css('width', '100px').on('click', fn)...，这也对应上了elf+js项目的题记——体验愉悦的JavaScript开发！so，elf是一个利用了JavaScript语言特性来让jslib用起来更简单，而不需要和java一样死板的东西，你也可以说elf只是一个壳，所有真实的功能其实都在jslib里。

至于你提到UI，由于我个人做过很多有复杂UI交互的界面系统，所以对UI的理解可能相对于经常使用jQuery UI的开发者来说，更倾向于类似Ext/dojo的体系化框架的处理方式。这种情况下，有一个更加整体全面的框架引擎规划会比只是零散的按需求出现来处理的UI元素会更有生命力。当然我不否认的确有很多简单零散的需求，但是一把武器肯定不能解决全部类型的敌人，正如我划分了jslib和elf一样，如果以后考虑开发UI体系，我也会把这当成两类事情来做。其中框架引擎化的UI体系我已经在考虑中，或许就沿袭elf的命名叫eui什么的。而简易化的零散组件体系还暂时没有考虑，或许到要用到的时候会去具体做一些思考。

对于移动来说，几乎全部代码也是天然支持的，就算要把代码应用到后端比如nodejs的环境，除js.dom.*和js.net.Ajax等特殊的依赖浏览器环境的功能以外，大多数包和类也应该是可用的，虽然我具体没有进行过后端环境的测试，但作为一个可以灵活扩展的库，我还是有信心让他也可以适应后端环境的。

你说到的require库按照CommonJS的思想来说，其实也是个不错的东西。但对目前的jslib体积（压缩后47k，gzip后16k）来说，有点杀鸡用牛刀的感觉。加入require的按需加载反而还要增加不少代码，这个问题就像网站只有100个用户而在初期就考虑要解决100w级的数据量一样，所以我们可以等到jslib长大以后再具体进行考虑:-P，毕竟现在一张图片就远远超过一个js库的大小了，而且今后的网络条件也应该会越来越好。

说了这么多，其实最需要思考的就是我们对设计一个js库产品的初衷和期待，这本是我自己一个人工作之余研究的一点小成果，还没想到是否以后可以走向工业化，所以会有这样的思考。既然已经放到了台前，那么也让我听听你的理解和思考，以及对elf+js的期待吧！

最后再次感谢你给elfjslib邮件组的第一封来信，以及你所有的建议，这是给我对elf+js继续努力莫大的鼓励！另外如果可以的话，我恳请允许我将来信的内容发布到elf+js的博客上（可以隐去来信的一些敏感信息），以便和更多开发者一起交流进步。

谢谢！

mytharcher
 </p>


<a href="/blog/2011/12/28/how-to-participate-in-elfjs-via-franky.html">Read more...</a>

<br/>

<h2>
<a href=/blog/2011/12/27/0.3.1-release-note.html>elf+js[0.3.1]发布</a>
<a href="/blog/category/release"><span class="label label-info">release</span></a>

</h2> 
<small>时间:2011-12-27 00:00:00 +0800 </small>


<span>
	
	<a href="/blog/tags/0.3.1"><span class="label label-info">0.3.1</span></a>
	
	<a href="/blog/tags/elf+js"><span class="label label-info">elf+js</span></a>
	
	<a href="/blog/tags/release"><span class="label label-info">release</span></a>
	
	<a href="/blog/tags/bugfix"><span class="label label-info">bugfix</span></a>
	
	<a href="/blog/tags/发布"><span class="label label-info">发布</span></a>
	
	<a href="/blog/tags/版本"><span class="label label-info">版本</span></a>
	
</span>


<hr>


<p> 上一个版本（0.3.0）发布后发现一些问题，所以在修复后紧急更新了代码和并发布这个新版本0.3.1。

你可以到项目的下载页面获取相关的发布代码，或者直接通过下面的链接来下载：


  0.3.1（）
  0.3.1（）


0.3.1版本变更记录：

Included file ‘version/0.3.1.md’ not found in _includes directory
 </p>


<a href="/blog/2011/12/27/0.3.1-release-note.html">Read more...</a>

<br/>

<h2>
<a href=/blog/2011/12/25/0.3.0-release-note.html>elf+js[0.3.0]正式发布</a>
<a href="/blog/category/release"><span class="label label-info">release</span></a>

</h2> 
<small>时间:2011-12-25 00:00:00 +0800 </small>


<span>
	
	<a href="/blog/tags/0.3.0"><span class="label label-info">0.3.0</span></a>
	
	<a href="/blog/tags/elf+js"><span class="label label-info">elf+js</span></a>
	
	<a href="/blog/tags/release"><span class="label label-info">release</span></a>
	
	<a href="/blog/tags/发布"><span class="label label-info">发布</span></a>
	
	<a href="/blog/tags/版本"><span class="label label-info">版本</span></a>
	
</span>


<hr>


<p> 在一年半的积累和半年的发布准备后，完成了0.3.0所有的代码和文档的修订，于是终于把自己闭门造的轮子推到台前来和更多前端开发者交流。

现在我非常高兴的公开发布elf+js 0.3.0这个首个里程碑标志的版本！你可以到项目的下载页面获取相关的发布代码，或者直接通过下面的链接来下载：


  0.3.0（）
  0.3.0（）


你可以注意到现在的版本号是第一位0开头的，说明elf+js可能还有很多不完善的地方，甚至可能还有一些没发现的BUG，如果你在使用中遇到问题，请随时向我们反馈，一旦确认我们会尽快处理。

关于这个项目的解释如果找我交流也许能说上个一天一夜，所以太多的东西我就不在发布帖里说了，请直接围观elf+js项目的文档列表，以及之前发过的几篇博客：


  为何重复造轮子
  elf+js的设计理念（上）：基础库结构设计
  elf+js的设计理念（下）：针对基础库易用性的设计


最后非常感谢帮助项目命名的acelan，以及在设计上给了我很大启发并提供了很多建议的errorrik大牛！希望能借这个项目有更多开发者能够一起共同交流和进步。
 </p>


<a href="/blog/2011/12/25/0.3.0-release-note.html">Read more...</a>

<br/>

<h2>
<a href=/blog/2011/08/12/design-concept-of-elf.html>设计理念（下）：针对基础库易用性的设计</a>
<a href="/blog/category/introduction"><span class="label label-info">introduction</span></a>

</h2> 
<small>时间:2011-08-12 00:00:00 +0800 </small>


<span>
	
	<a href="/blog/tags/elf"><span class="label label-info">elf</span></a>
	
	<a href="/blog/tags/JavaScript"><span class="label label-info">JavaScript</span></a>
	
	<a href="/blog/tags/js"><span class="label label-info">js</span></a>
	
	<a href="/blog/tags/library"><span class="label label-info">library</span></a>
	
	<a href="/blog/tags/Shortcut"><span class="label label-info">Shortcut</span></a>
	
	<a href="/blog/tags/基础库"><span class="label label-info">基础库</span></a>
	
	<a href="/blog/tags/易用性"><span class="label label-info">易用性</span></a>
	
	<a href="/blog/tags/设计"><span class="label label-info">设计</span></a>
	
</span>


<hr>


<p> 上一篇提到“针对底层API规范的设计和易用性的设计有时候是互斥的”，从jQuery就可以看出，基本上对jQ的扩展最多的就是他的插件机制（我当年还翻译过《Learning jQuery》的第十章：插件。但由于翻译的太烂，没被采纳。），而jQ的插件只遵循一条最简单的规范，就是在jQuery.fn（相当于jQuery.prototype）上扩展方法，以成为对jQuery对象的插件。但是当引入了太多的插件后却没有一个分类管理的方式显得jQ的插件规范不是很完美，特别针对于大型系统，我不知道使用jQ的团队是如何管理和部署代码的。对着jQ废话了一大堆，其实想说的是jQ把基础库的易用性做到了极致，但是我觉得他在支撑一个大型系统的规范上略有不足。 如果再对比看看百度的Tangram，对于基本结构的规范是定义的很好的，一切对象要求完成最简单的功能，一切结构都建立在“命名空间.包名.对象名”之上。这样至少会影响真正应用的业务代码，也按照这个结构来进行生长发育。虽然这个结构非常清晰，但实际上用起来很复杂，也很痛苦，每次对基础库的调用都要写很长一串点，虽然通过基于顶级命名空间“baidu”声明了很多快捷方式，但这种声明又缺乏一种规范，甚至感觉略有点随意。所以在业务开发者使用的时候会远不如jQ写起来爽。 好了，那现在的问题变成了我既需要Tangram那样规范的可拆分代码结构，也想要使用的时候想jQ那样便捷，如何才能做到两全其美呢？ 于是我开始分析jQuery带来开发便利性的原因所在，顶级函数$()，根据传入的参数不同，会执行不同的操作，大多数类型如：String（选择器），Element，Document，Window，Array（，NodeList等）都会生成一个包含一个或多个元素的jQuery对象，在之后就可以随意的使用jQuery对象上prototype定义的方法进行各种操作，并且一直链式调用下去。而如果传入的类型是函数，则自动转到jQuery.ready去做一个等待执行。这样看快捷方式最核心的内容就是一个函数的重载。 对于jQuery对象这种元素包装机制对大多数web开发来说是非常常用的，所以我在基础库中编写了专门为此进行处理的js.dom.Node类，而ready的处理也对应到了js.dom.Stage.ready这个静态方法，现在我要做的只是设计一个从顶级命名空间就可以直接使用这两个东西的快捷方式。 从这里考虑，顶级命名空间就不能只是一个包含子级包的对象，他需要成为一个入口函数，然后对不同的参数情况进行分发。我最早的设计只是简单的照搬jQuery对象构造函数的写法，在里面进行参数的类型判断（包括字符串选择器的模式），然后再做对应处理。但后来发现这本身只是一个函数重载的事情，不应该把顶级对象搞的太复杂，所以这段逻辑需要抽取出去，只留一个分发的处理即可。 基于需要对以上功能的支持，我专门编写了根据对象输出对应类型字符串标识的js.util.Type.of方法，以及用于创建分发器的js.util.Shortcut类。并有了顶级分发器的第二个版本： var elf = elf || function (args) {     return elf.util.Shortcut.dispatch(args); } elf.util.Shortcut.attach(elf); ///import elf.util.Shortcut; 当时elf就是基础库的名字，还没有使用js来进行拆分，这造成的一个特殊的地方就是顶级命名空间和在他之下定义的类形成了循环依赖，虽然我可以用后置依赖的方式来解决打包顺序的问题，但这样的写法还是略有一些诡异，而且不能直接使用Shortcut类的工厂方法create来创建一个快捷对象。最重要的是干扰了基础库的基本功能和设计规范——做最简单的事情，而不应该为了易用性随意的污染基础库。所以在采纳了erik拆分的建议后，启用了js这个命名空间来放置基础库，而elf成为了专为组织各种基础库快捷方式的对象，快捷方式的定义也变成了下面的方式： var elf = js.util.Shortcut.create(); 在定义之后可以和原来一样为快捷对象添加各种拦截器以达到分发不同处理的目的。例如： //将String类型的参数认为是选择器表达式，并交由Node类处理 js.util.Shortcut.intercept(elf, js.util.Type.STRING, js.dom.Node); //将DOM元素交由Node包装处理 js.util.Shortcut.intercept(elf, js.util.Type.ELEMENT, js.dom.Node); //将函数交由全局准备执行队列处理 js.util.Shortcut.intercept(elf, js.util.Type.FUNCTION, js.dom.Stage.ready); 除了添加顶级快捷处理，Shortcut的dispatch还有一个默认的特殊处理，即没有传入任何参数或者传入的参数是undefined，那么Shortcut会转向到一个快捷方法镜像映射表上，以支持在后续的.xxx可以调用镜像映射过的各种静态方法，达到缩短很多静态方法书写长度的目的，例如： //声明对elf快捷对象使用Class类中的静态方法 js.util.Shortcut.use(elf, {     clone: js.util.Class.clone,     copy:... </p>


<a href="/blog/2011/08/12/design-concept-of-elf.html">Read more...</a>

<br/>

<h2>
<a href=/blog/2011/08/03/design-concept-of-jslib.html>设计理念（上）：基础库结构设计</a>
<a href="/blog/category/introduction"><span class="label label-info">introduction</span></a>

</h2> 
<small>时间:2011-08-03 00:00:00 +0800 </small>


<span>
	
	<a href="/blog/tags/JavaScript"><span class="label label-info">JavaScript</span></a>
	
	<a href="/blog/tags/js"><span class="label label-info">js</span></a>
	
	<a href="/blog/tags/library"><span class="label label-info">library</span></a>
	
	<a href="/blog/tags/基础库"><span class="label label-info">基础库</span></a>
	
	<a href="/blog/tags/结构设计"><span class="label label-info">结构设计</span></a>
	
	<a href="/blog/tags/规范"><span class="label label-info">规范</span></a>
	
</span>


<hr>


<p> 对于一个JavaScript基础库，最重要的无外乎API简单，稳定，有良好的通用性，只解决最基本的问题，同时便于理解学习。其实这么说起来很像百度的Tangram的初衷，但elf+js还是略有不同。

虽然JavaScript不是一门支持面向对象编程的语言，但他具有很多面向对象的特性。如果利用得当，面向对象的编程方法将是使用JS构建大型Web应用的较为容易分清各种模块结构的方式。基础库会涵盖很多基本的功能基于这个思路，如果按jQuery针对DOM的设计是不合适的，所有的扩展都会依附在jQuery对象本身上，很难从一个巨长的插件列表上方便的区分各种功能的类型。所以我转向参考了dojo、YUI、Ext和Tangram等，还是设计了“命名空间.包名.类名”的代码组织形式。同时我坚持使用了Java中命名规范：


  包名小写，如：js，js.dom，js.net等；
  类名首字母大写驼峰，如：js.dom.ClassName，js.net.Ajax等；
  类成员(变量/方法)首字母小写驼峰，如：js.dom.ClassName.add()，js.net.Ajax.option等；
  常量命名全部大写，如：js.net.Ajax.HTTP_GET等；
  类名、包结构与文件名、文件夹一一对应；


这样设计的好处是结构条理清晰，便于理解和统一认识。

规范上除了上面的命名大小写等，还有一点最重要的就是所有的功能设计都需要依附于一个类，就算是很常用很通用的方法。例如给DOM元素添加class的addClass方法，在Tangram中这个API是baidu.dom.addClass，而在elf+js里是js.dom.ClassName.add。看起来长了一级命名空间，的确是很不方便，还有可能不利于理解，但实际上这是一种对认识的统一，因为这样规范了写法以后，不会出现一个包下既有类又有方法的情况。而且现在看起来可能难用一点，但是配合上elf以后就会变的非常简单。针对底层API规范的设计和易用性的设计有时候是互斥的，这个话题以后会谈到。

在文件划分粒度上主要以类为主，每一个类即一个文件，因为这都是包含同一组方法的相关功能，但允许一些相关性不大的静态方法的定义文件独立于主类文件之外。这样做的考虑是在打包的时候可以灵活选取需要的和剪除不要的，以达到最小导出打包的目的，同时方法仍是依附于一个类的，也不违反上面定义的规范。这个特性相关的例子可以在js.dom.Stage.*里查到。

综合上面提到的这些方面来看，elf+js的底层API部分是非常灵活的，可以任意的加入更多功能，而且通过这样的命名方式也很容易找到常用的API位置，再配合API文档，学习起来就变的非常简单了。
 </p>


<a href="/blog/2011/08/03/design-concept-of-jslib.html">Read more...</a>

<br/>


	</div>
	<div class="span3">
		<div class="slidebar span3">
	<div class="">
	<h3>标签云</h3>

				<a href="/blog/tags/0.3.0">
					<span style="font-size:75%">0.3.0</span> 
				</a>
				
				<a href="/blog/tags/0.3.1">
					<span style="font-size:75%">0.3.1</span> 
				</a>
				
				<a href="/blog/tags/0.3.2">
					<span style="font-size:75%">0.3.2</span> 
				</a>
				
				<a href="/blog/tags/0.3.3">
					<span style="font-size:75%">0.3.3</span> 
				</a>
				
				<a href="/blog/tags/JavaScript">
					<span style="font-size:211%">JavaScript</span> 
				</a>
				
				<a href="/blog/tags/Shortcut">
					<span style="font-size:75%">Shortcut</span> 
				</a>
				
				<a href="/blog/tags/bugfix">
					<span style="font-size:211%">bugfix</span> 
				</a>
				
				<a href="/blog/tags/elf">
					<span style="font-size:143%">elf</span> 
				</a>
				
				<a href="/blog/tags/elf+js">
					<span style="font-size:280%">elf+js</span> 
				</a>
				
				<a href="/blog/tags/js">
					<span style="font-size:211%">js</span> 
				</a>
				
				<a href="/blog/tags/library">
					<span style="font-size:211%">library</span> 
				</a>
				
				<a href="/blog/tags/project">
					<span style="font-size:75%">project</span> 
				</a>
				
				<a href="/blog/tags/release">
					<span style="font-size:280%">release</span> 
				</a>
				
				<a href="/blog/tags/snyh">
					<span style="font-size:75%">snyh</span> 
				</a>
				
				<a href="/blog/tags/test">
					<span style="font-size:75%">test</span> 
				</a>
				
				<a href="/blog/tags/交流">
					<span style="font-size:75%">交流</span> 
				</a>
				
				<a href="/blog/tags/原因">
					<span style="font-size:75%">原因</span> 
				</a>
				
				<a href="/blog/tags/参与">
					<span style="font-size:75%">参与</span> 
				</a>
				
				<a href="/blog/tags/发布">
					<span style="font-size:280%">发布</span> 
				</a>
				
				<a href="/blog/tags/基础库">
					<span style="font-size:211%">基础库</span> 
				</a>
				
				<a href="/blog/tags/想法">
					<span style="font-size:75%">想法</span> 
				</a>
				
				<a href="/blog/tags/易用性">
					<span style="font-size:75%">易用性</span> 
				</a>
				
				<a href="/blog/tags/来信">
					<span style="font-size:75%">来信</span> 
				</a>
				
				<a href="/blog/tags/版本">
					<span style="font-size:280%">版本</span> 
				</a>
				
				<a href="/blog/tags/积累">
					<span style="font-size:75%">积累</span> 
				</a>
				
				<a href="/blog/tags/结构设计">
					<span style="font-size:75%">结构设计</span> 
				</a>
				
				<a href="/blog/tags/规范">
					<span style="font-size:75%">规范</span> 
				</a>
				
				<a href="/blog/tags/设计">
					<span style="font-size:75%">设计</span> 
				</a>
				
				<a href="/blog/tags/轮子">
					<span style="font-size:75%">轮子</span> 
				</a>
				
	</div>

	<div class="">
	<h3>文章分类</h3>
<a href="/blog/category/communication">communication <strong>(1)</strong></a><br/><a href="/blog/category/release">release <strong>(4)</strong></a><br/><a href="/blog/category/test">test <strong>(1)</strong></a><br/><a href="/blog/category/blogtest2">blogtest2 <strong>(1)</strong></a><br/><a href="/blog/category/blogtest">blogtest <strong>(1)</strong></a><br/><a href="/blog/category/introduction">introduction <strong>(3)</strong></a><br/>
	</div>

	<div class="">
	<h3>文章归档</h3>
<a href="/blog/2012#m3">2012/3 <strong>(3)</strong></a><br/><a href="/blog/2012#m2">2012/2 <strong>(2)</strong></a><br/><a href="/blog/2011#m12">2011/12 <strong>(3)</strong></a><br/><a href="/blog/2011#m8">2011/8 <strong>(3)</strong></a><br/>
	</div>
</div>

	</div>
</div>



<div id="Footer">
create by snyh
</div>

</div>

<script src="/assets/js/jquery-1.7.1.min.js"></script>
<script src="/assets/js/bootstrap.min.js"></script>


<script>
$(function(){

});

var jiathis_config = {data_track_clickback:true};
</script>


</body>
</html>
