<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="author" content="">
<meta name="keywords" content="">
<title> snyh  </title>
<link rel="stylesheet" href="/assets/css/bootstrap.min.css">
<link rel="stylesheet" href="/assets/css/page.css">


<style>
body {
	padding-top: 60px;
}
</style>
<link href="/assets/css/bootstrap-responsive.min.css" rel="stylesheet">
<!--[if lt IE9]>
<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
<![endif]-->
<link rel="shortcut icon" href="/assets/img/favicon.png">
</head>
<body>

<div class="navbar navbar-fixed-top">
<div class="navbar-inner">

<div class="container">

<a class="brand" href=""> snyh.org </a>

<ul class="nav">

<li><a href=/>主页</a></li>

<li><a href=/blog/>随笔</a></li>

<li><a href=/album/>往夕</a></li>

<li><a href=/project/>实验田</a></li>

<li><a href=/about.html>关于</a></li>

</ul>

<div class="pull-right">

<!-- JiaThis Button BEGIN -->
<span id="jiathis_style_32x32">
	<a class="jiathis_button_tsina"></a>
	<a class="jiathis_button_tqq"></a>
	<a class="jiathis_button_renren"></a>
	<a class="jiathis_button_kaixin001"></a>
	<a class="jiathis_button_douban"></a>
	<a class="jiathis_button_qzone"></a>
	<a class="jiathis_button_pdfonline"></a>
	<a href="http://www.jiathis.com/share?uid=1584728" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	<a class="jiathis_counter_style"></a>
</span>
<!-- JiaThis Button END -->

<input type="text" class="search-query" placeholder="Search">
</div>

</div>

</div>
</div>




<div class="container">
<div class="row">
<div class="span9">
			<span><strong></strong></span> 
			<small></small>

<hr>


<h2>
<a href=/blog/2011/08/03/design-concept-of-jslib.html>设计理念（上）：基础库结构设计</a>
<a href="/blog/category/introduction"><span class="label label-info">introduction</span></a>

</h2> 
<small>时间:2011-08-03 00:00:00 +0800 </small>


<span>
	
	<a href="/blog/tags/JavaScript"><span class="label label-info">JavaScript</span></a>
	
	<a href="/blog/tags/js"><span class="label label-info">js</span></a>
	
	<a href="/blog/tags/library"><span class="label label-info">library</span></a>
	
	<a href="/blog/tags/基础库"><span class="label label-info">基础库</span></a>
	
	<a href="/blog/tags/结构设计"><span class="label label-info">结构设计</span></a>
	
	<a href="/blog/tags/规范"><span class="label label-info">规范</span></a>
	
</span>


<hr>


<p> 对于一个JavaScript基础库，最重要的无外乎API简单，稳定，有良好的通用性，只解决最基本的问题，同时便于理解学习。其实这么说起来很像百度的Tangram的初衷，但elf+js还是略有不同。

虽然JavaScript不是一门支持面向对象编程的语言，但他具有很多面向对象的特性。如果利用得当，面向对象的编程方法将是使用JS构建大型Web应用的较为容易分清各种模块结构的方式。基础库会涵盖很多基本的功能基于这个思路，如果按jQuery针对DOM的设计是不合适的，所有的扩展都会依附在jQuery对象本身上，很难从一个巨长的插件列表上方便的区分各种功能的类型。所以我转向参考了dojo、YUI、Ext和Tangram等，还是设计了“命名空间.包名.类名”的代码组织形式。同时我坚持使用了Java中命名规范：

* 包名小写，如：`js`，`js.dom`，`js.net`等；
* 类名首字母大写驼峰，如：`js.dom.ClassName`，`js.net.Ajax`等；
* 类成员(变量/方法)首字母小写驼峰，如：`js.dom.ClassName.add()`，`js.net.Ajax.option`等；
* 常量命名全部大写，如：`js.net.Ajax.HTTP_GET`等；
* 类名、包结构与文件名、文件夹一一对应；

这样设计的好处是结构条理清晰，便于理解和统一认识。

规范上除了上面的命名大小写等，还有一点最重要的就是所有的功能设计都需要依附于一个类，就算是很常用很通用的方法。例如给DOM元素添加class的`addClass`方法，在Tangram中这个API是`baidu.dom.addClass`，而在elf+js里是`js.dom.ClassName.add`。看起来长了一级命名空间，的确是很不方便，还有可能不利于理解，但实际上这是一种对认识的统一，因为这样规范了写法以后，不会出现一个包下既有类又有方法的情况。而且现在看起来可能难用一点，但是配合上elf以后就会变的非常简单。针对底层API规范的设计和易用性的设计有时候是互斥的，这个话题以后会谈到。

在文件划分粒度上主要以类为主，每一个类即一个文件，因为这都是包含同一组方法的相关功能，但允许一些相关性不大的静态方法的定义文件独立于主类文件之外。这样做的考虑是在打包的时候可以灵活选取需要的和剪除不要的，以达到最小导出打包的目的，同时方法仍是依附于一个类的，也不违反上面定义的规范。这个特性相关的例子可以在`js.dom.Stage.*`里查到。

综合上面提到的这些方面来看，elf+js的底层API部分是非常灵活的，可以任意的加入更多功能，而且通过这样的命名方式也很容易找到常用的API位置，再配合API文档，学习起来就变的非常简单了。
 </p>


<a href="/blog/2011/08/03/design-concept-of-jslib.html">Read more...</a>

<br/>

<h2>
<a href=/blog/2011/08/02/why-made-this-wheel.html>为何重复造轮子</a>
<a href="/blog/category/introduction"><span class="label label-info">introduction</span></a>

</h2> 
<small>时间:2011-08-02 00:00:00 +0800 </small>


<span>
	
	<a href="/blog/tags/elf"><span class="label label-info">elf</span></a>
	
	<a href="/blog/tags/JavaScript"><span class="label label-info">JavaScript</span></a>
	
	<a href="/blog/tags/js"><span class="label label-info">js</span></a>
	
	<a href="/blog/tags/library"><span class="label label-info">library</span></a>
	
	<a href="/blog/tags/基础库"><span class="label label-info">基础库</span></a>
	
	<a href="/blog/tags/轮子"><span class="label label-info">轮子</span></a>
	
	<a href="/blog/tags/原因"><span class="label label-info">原因</span></a>
	
	<a href="/blog/tags/积累"><span class="label label-info">积累</span></a>
	
</span>


<hr>


<p> 凡事都要有原因，不管重复造轮子这件事好还是坏。

最早想写一个JS库是因为2007年的时候看到jQuery这么NB的写法，当时完全被震撼了，开始萌生把jQ拆开来用的想法。但当时才疏学浅，JS没写过多少，打开jQ的源码以后完全无法理解里面各种精妙的设计，怎么`$('#id')`就成了一个看似数组但又不是数组，到这就无法理解了。之后就没再进行下去，直到后来在百度erik给大家做技术交流时讲解了JS里prototype的机制后我才有所顿悟。再后来，公司各种开发任务压下来，很长时间里没再仔细分析jQ的代码，只在项目用到的地方，逐渐的剥离出一些常用的东西，比如Event和Ajax等。

而公司对jQ一直是不提倡在各产品线内使用的，原因是当时的jQ还不是很稳定，如果出了问题很难查出原因，特别要用的是压缩过的源码。这样带来的后果就是公司内各个团队都开始积累适合自己产品线的基础库，当然，这件事我也在做。所以几年下来，随着产品线的丰富，产品的功能复杂化，我也积累了很多基础库的代码。

直到2010年初我再次转换产品线负责重构一个系统的前端架构时，这些年积累的一堆代码还算能用，而且对比2009年公司内前端统一推的Tangram，我觉得我这些代码更符合我所认定的一种编码规范（类似Java的组织结构）和使用习惯，所以没有完全放弃去直接使用公司的Tangram。这里并不是说Tangram不好，从很多方面讲Tangram的设计是非常好的，只是不符合我所认同的一种规范，使用起来也很不舒服，更改习惯是困难的。

后来和晓斌商量把这些代码推出来，可以做一个使用起来更舒服的基础库，因为里面现在很多特性是很有价值的，也是其他库所不具备的。于是开始给这个库想名字，我没想出几个合适的来，但晓斌提了几个中的一个`elf`立马电击到了我，所以就定下了这个名字。

接下来一段时间就先把大部分代码投入到新的产品线中使用，因为觉得还有些缺陷，所以没有对外发布，同时也在不断完善。产品线开发时一直没有顾的上太多，直到系统重构上线后，又腾出一些时间来把elf的组织调整到一个更加规范的结构，才开始着手考虑发布的事情。

今年初开始为发布筹备各方面的东西，再次把整体的代码给erik帮我全部review了一次，他提出一个很好的建议：把基础功能部分和对一个库进行易用性优化的部分拆开。我觉得elf这个名字更适合一个易用性的封装，而基础功能部分我更希望可以是一种标准化的API，于是干脆大言不惭的占用了`js.*`这个命名空间，所以最后就有了“elf+js”。

简单的说原因就这么几点：

* 想把jQuery拆开用；
* 自己的代码有了积累，不想放弃自己的劳动成果，作为给自己写代码这么些年的一个交代；
* 写代码写自己的库是学习的一个必经过程；
* 还有就是对这些代码的设计有那么点沾沾自喜。

所以，有了这个轮子。
 </p>


<a href="/blog/2011/08/02/why-made-this-wheel.html">Read more...</a>

<br/>

<h2>
<a href=/blog/2011/08/12/design-concept-of-elf.html>设计理念（下）：针对基础库易用性的设计</a>
<a href="/blog/category/introduction"><span class="label label-info">introduction</span></a>

</h2> 
<small>时间:2011-08-12 00:00:00 +0800 </small>


<span>
	
	<a href="/blog/tags/elf"><span class="label label-info">elf</span></a>
	
	<a href="/blog/tags/JavaScript"><span class="label label-info">JavaScript</span></a>
	
	<a href="/blog/tags/js"><span class="label label-info">js</span></a>
	
	<a href="/blog/tags/library"><span class="label label-info">library</span></a>
	
	<a href="/blog/tags/Shortcut"><span class="label label-info">Shortcut</span></a>
	
	<a href="/blog/tags/基础库"><span class="label label-info">基础库</span></a>
	
	<a href="/blog/tags/易用性"><span class="label label-info">易用性</span></a>
	
	<a href="/blog/tags/设计"><span class="label label-info">设计</span></a>
	
</span>


<hr>


<p> [上一篇](design-concept-of-jslib.html)提到“针对底层API规范的设计和易用性的设计有时候是互斥的”，从jQuery就可以看出，基本上对jQ的扩展最多的就是他的插件机制（我当年还翻译过《Learning jQuery》的第十章：插件。但由于翻译的太烂，没被采纳。），而jQ的插件只遵循一条最简单的规范，就是在`jQuery.fn`（相当于`jQuery.prototype`）上扩展方法，以成为对jQuery对象的插件。但是当引入了太多的插件后却没有一个分类管理的方式显得jQ的插件规范不是很完美，特别针对于大型系统，我不知道使用jQ的团队是如何管理和部署代码的。对着jQ废话了一大堆，其实想说的是jQ把基础库的易用性做到了极致，但是我觉得他在支撑一个大型系统的规范上略有不足。 如果再对比看看百度的Tangram，对于基本结构的规范是定义的很好的，一切对象要求完成最简单的功能，一切结构都建立在“命名空间.包名.对象名”之上。这样至少会影响真正应用的业务代码，也按照这个结构来进行生长发育。虽然这个结构非常清晰，但实际上用起来很复杂，也很痛苦，每次对基础库的调用都要写很长一串点，虽然通过基于顶级命名空间“baidu”声明了很多快捷方式，但这种声明又缺乏一种规范，甚至感觉略有点随意。所以在业务开发者使用的时候会远不如jQ写起来爽。 好了，那现在的问题变成了我既需要Tangram那样规范的可拆分代码结构，也想要使用的时候想jQ那样便捷，如何才能做到两全其美呢？ 于是我开始分析jQuery带来开发便利性的原因所在，顶级函数$()，根据传入的参数不同，会执行不同的操作，大多数类型如：String（选择器），Element，Document，Window，Array（，NodeList等）都会生成一个包含一个或多个元素的jQuery对象，在之后就可以随意的使用jQuery对象上prototype定义的方法进行各种操作，并且一直链式调用下去。而如果传入的类型是函数，则自动转到`jQuery.ready`去做一个等待执行。这样看快捷方式最核心的内容就是一个函数的重载。 对于jQuery对象这种元素包装机制对大多数web开发来说是非常常用的，所以我在基础库中编写了专门为此进行处理的`js.dom.Node`类，而ready的处理也对应到了`js.dom.Stage.ready`这个静态方法，现在我要做的只是设计一个从顶级命名空间就可以直接使用这两个东西的快捷方式。 从这里考虑，顶级命名空间就不能只是一个包含子级包的对象，他需要成为一个入口函数，然后对不同的参数情况进行分发。我最早的设计只是简单的照搬jQuery对象构造函数的写法，在里面进行参数的类型判断（包括字符串选择器的模式），然后再做对应处理。但后来发现这本身只是一个函数重载的事情，不应该把顶级对象搞的太复杂，所以这段逻辑需要抽取出去，只留一个分发的处理即可。 基于需要对以上功能的支持，我专门编写了根据对象输出对应类型字符串标识的`js.util.Type.of`方法，以及用于创建分发器的`js.util.Shortcut`类。并有了顶级分发器的第二个版本： var elf = elf || function (args) {     return elf.util.Shortcut.dispatch(args); } elf.util.Shortcut.attach(elf); ///import elf.util.Shortcut; 当时elf就是基础库的名字，还没有使用js来进行拆分，这造成的一个特殊的地方就是顶级命名空间和在他之下定义的类形成了循环依赖，虽然我可以用后置依赖的方式来解决打包顺序的问题，但这样的写法还是略有一些诡异，而且不能直接使用Shortcut类的工厂方法create来创建一个快捷对象。最重要的是干扰了基础库的基本功能和设计规范——做最简单的事情，而不应该为了易用性随意的污染基础库。所以在采纳了erik拆分的建议后，启用了js这个命名空间来放置基础库，而elf成为了专为组织各种基础库快捷方式的对象，快捷方式的定义也变成了下面的方式： var elf = js.util.Shortcut.create(); 在定义之后可以和原来一样为快捷对象添加各种拦截器以达到分发不同处理的目的。例如： //将String类型的参数认为是选择器表达式，并交由Node类处理 js.util.Shortcut.intercept(elf, js.util.Type.STRING, js.dom.Node); //将DOM元素交由Node包装处理 js.util.Shortcut.intercept(elf, js.util.Type.ELEMENT, js.dom.Node); //将函数交由全局准备执行队列处理 js.util.Shortcut.intercept(elf, js.util.Type.FUNCTION, js.dom.Stage.ready); 除了添加顶级快捷处理，Shortcut的dispatch还有一个默认的特殊处理，即没有传入任何参数或者传入的参数是undefined，那么Shortcut会转向到一个快捷方法镜像映射表上，以支持在后续的.xxx可以调用镜像映射过的各种静态方法，达到缩短很多静态方法书写长度的目的，例如： //声明对elf快捷对象使用Class类中的静态方法 js.util.Shortcut.use(elf, {     clone: js.util.Class.clone,     copy:... </p>


<a href="/blog/2011/08/12/design-concept-of-elf.html">Read more...</a>

<br/>



<hr>
		<ul class="pager">

<li class="previous"><a href="#">Nothing</a></li>



<li class="next"><a href="#">Nothing</a></li>


</ul>

<!-- PingLun.La Begin -->
<div id="pinglunla_here">
<span class="lable lable-info">评论系统载入中</span>
</div>
<!-- PingLun.La End -->

</div>
<div class="span3">
<div class="slidebar span3">
	<div class="">
	<h3>标签云</h3>

				<a href="/blog/tags/0.3.0">
					<span style="font-size:75%">0.3.0</span> 
				</a>
				
				<a href="/blog/tags/0.3.1">
					<span style="font-size:75%">0.3.1</span> 
				</a>
				
				<a href="/blog/tags/0.3.2">
					<span style="font-size:75%">0.3.2</span> 
				</a>
				
				<a href="/blog/tags/0.3.3">
					<span style="font-size:75%">0.3.3</span> 
				</a>
				
				<a href="/blog/tags/JavaScript">
					<span style="font-size:211%">JavaScript</span> 
				</a>
				
				<a href="/blog/tags/Shortcut">
					<span style="font-size:75%">Shortcut</span> 
				</a>
				
				<a href="/blog/tags/bugfix">
					<span style="font-size:211%">bugfix</span> 
				</a>
				
				<a href="/blog/tags/elf">
					<span style="font-size:143%">elf</span> 
				</a>
				
				<a href="/blog/tags/elf+js">
					<span style="font-size:280%">elf+js</span> 
				</a>
				
				<a href="/blog/tags/js">
					<span style="font-size:211%">js</span> 
				</a>
				
				<a href="/blog/tags/library">
					<span style="font-size:211%">library</span> 
				</a>
				
				<a href="/blog/tags/project">
					<span style="font-size:75%">project</span> 
				</a>
				
				<a href="/blog/tags/release">
					<span style="font-size:280%">release</span> 
				</a>
				
				<a href="/blog/tags/snyh">
					<span style="font-size:75%">snyh</span> 
				</a>
				
				<a href="/blog/tags/test">
					<span style="font-size:75%">test</span> 
				</a>
				
				<a href="/blog/tags/交流">
					<span style="font-size:75%">交流</span> 
				</a>
				
				<a href="/blog/tags/原因">
					<span style="font-size:75%">原因</span> 
				</a>
				
				<a href="/blog/tags/参与">
					<span style="font-size:75%">参与</span> 
				</a>
				
				<a href="/blog/tags/发布">
					<span style="font-size:280%">发布</span> 
				</a>
				
				<a href="/blog/tags/基础库">
					<span style="font-size:211%">基础库</span> 
				</a>
				
				<a href="/blog/tags/想法">
					<span style="font-size:75%">想法</span> 
				</a>
				
				<a href="/blog/tags/易用性">
					<span style="font-size:75%">易用性</span> 
				</a>
				
				<a href="/blog/tags/来信">
					<span style="font-size:75%">来信</span> 
				</a>
				
				<a href="/blog/tags/版本">
					<span style="font-size:280%">版本</span> 
				</a>
				
				<a href="/blog/tags/积累">
					<span style="font-size:75%">积累</span> 
				</a>
				
				<a href="/blog/tags/结构设计">
					<span style="font-size:75%">结构设计</span> 
				</a>
				
				<a href="/blog/tags/规范">
					<span style="font-size:75%">规范</span> 
				</a>
				
				<a href="/blog/tags/设计">
					<span style="font-size:75%">设计</span> 
				</a>
				
				<a href="/blog/tags/轮子">
					<span style="font-size:75%">轮子</span> 
				</a>
				
	</div>

	<div class="">
	<h3>文章分类</h3>
<a href="/blog/category/communication">communication <strong>(1)</strong></a><br/><a href="/blog/category/release">release <strong>(4)</strong></a><br/><a href="/blog/category/test">test <strong>(1)</strong></a><br/><a href="/blog/category/blogtest2">blogtest2 <strong>(1)</strong></a><br/><a href="/blog/category/blogtest">blogtest <strong>(1)</strong></a><br/><a href="/blog/category/introduction">introduction <strong>(3)</strong></a><br/>
	</div>

	<div class="">
	<h3>文章归档</h3>
<a href="/blog/2012#m3">2012/3 <strong>(3)</strong></a><br/><a href="/blog/2012#m2">2012/2 <strong>(2)</strong></a><br/><a href="/blog/2011#m12">2011/12 <strong>(3)</strong></a><br/><a href="/blog/2011#m8">2011/8 <strong>(3)</strong></a><br/>
	</div>
</div>

</div>
</div>


<div id="Footer">
create by snyh
</div>

</div>

<script src="/assets/js/jquery-1.7.1.min.js"></script>
<script src="/assets/js/bootstrap.min.js"></script>


<script>
$(function(){

});

var jiathis_config = {data_track_clickback:true};
</script>


</body>
</html>
